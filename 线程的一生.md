# 线程的一生

线程是 CPU 调度的基本单位。Java 中线程状态分为：

* New：创建状态
* Runable：可运行状态
* Waiting：等待状态
* Timed Waiting：限时等待状态
* Blocking：阻塞状态
* Terminated：结束状态

[Thread.State](https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.State.html) 中介绍了各个状态的含义。

## Runable

**创建（new）** 后的线程对象，调用 `start` 进入可运行状态。

Runable 现场并没有立即执行，而是分为两步：ready to run 和 running。因为线程进入可运行状态后仍然需要等待某些资源，最常见的是等待 CPU 调度资源或 IO 资源。

线程执行结束后，进入了结束状态。

## Waiting

线程会以 3 种不同方式进入等待状态，然后以各自的方式被唤醒。

### Object.wait()

`Object.wait()` 调用后，线程需要先放弃对象锁（放弃失败抛出 [IllegalMonitorStateException](https://docs.oracle.com/javase/8/docs/api/java/lang/IllegalMonitorStateException.html)），然后被推进 **线程等待队列（Thread Waiting Set**），等待其他线程的唤醒。

其他线程调用 Object.notify() 会 **随机** 唤醒等待队列中的一个线程。为了公平性，该线程并没有直接进入可运行状态，而是重新开始了锁竞争，成功获取锁权限后才进入可运行状态。否则，线程会因为竞争锁失败而进入 **阻塞（Blocking）**，一直到获取锁权限。

`Object.notifyAll()` 会唤醒等待队列中的所有线程，后续过程与 `Object.wait()` 相同。

特别注意：

1. 等待线程仍然可以相应中断，但是需要竞争到锁权限后才会抛出 [InterruptedException](https://docs.oracle.com/javase/8/docs/api/java/lang/InterruptedException.html)

2. 等待线程有可能（概率尽管很小）出现 **意外唤醒（Surprise Wakeup）**，因此通常在循环中调用 `wait()` 方法

3. ```java
    private final Object object = new Object();
    ....
    synchronized (object) {
        while (condition) {
            object.wait();
        }
    }
    ```

### Thread.sleep()



### LockSupport.park()

